"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NtlmProxyMitm = void 0;
const inversify_1 = require("inversify");
const net_1 = __importDefault(require("net"));
const dependency_injection_types_1 = require("./dependency.injection.types");
const url_ext_1 = require("../util/url.ext");
let self;
const httpTokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;
let NtlmProxyMitm = class NtlmProxyMitm {
    constructor(configStore, portsConfigStore, connectionContextManager, winSsoFacadeFactory, negotiateManager, ntlmManager, upstreamProxyManager, httpsValidation, debug) {
        this._configStore = configStore;
        this._portsConfigStore = portsConfigStore;
        this._connectionContextManager = connectionContextManager;
        this._winSsoFacadeFactory = winSsoFacadeFactory;
        this._negotiateManager = negotiateManager;
        this._ntlmManager = ntlmManager;
        this._upstreamProxyManager = upstreamProxyManager;
        this._httpsValidation = httpsValidation;
        this._debug = debug;
        // Keep track of instance since methods will be triggered from HttpMitmProxy
        // events which means that 'this' is no longer the class instance
        self = this;
    }
    filterChromeStartup(ctx, errno, errorKind) {
        if (!ctx || !ctx.clientToProxyRequest || !errno) {
            return false;
        }
        const req = ctx.clientToProxyRequest;
        if (req.method === "HEAD" &&
            req.url === "/" &&
            req.headers.host &&
            req.headers.host.indexOf(".") === -1 &&
            (req.headers.host.indexOf(":") === -1 ||
                req.headers.host.indexOf(":80") !== -1) &&
            req.headers.host.indexOf("/") === -1 &&
            errorKind === "PROXY_TO_SERVER_REQUEST_ERROR" &&
            errno === "ENOTFOUND") {
            self._debug.log("Chrome startup HEAD request detected (host: " +
                req.headers.host +
                "). Ignoring connection error.");
            return true;
        }
    }
    onError(ctx, error, errorKind) {
        var _a;
        if (self.filterChromeStartup(ctx, error.code, errorKind)) {
            return;
        }
        const url = ctx && ctx.clientToProxyRequest ? ctx.clientToProxyRequest.url : "";
        if (errorKind === "PROXY_TO_SERVER_REQUEST_ERROR") {
            // Act transparent - client will receive a network error instead of a 504
            self._debug.log(errorKind + " on " + url + ":", error, "Destroying client socket.");
            (_a = ctx.proxyToClientResponse.socket) === null || _a === void 0 ? void 0 : _a.destroy();
        }
        else {
            self._debug.log(errorKind + " on " + url + ":", error);
        }
    }
    isConfigApiRequest(targetHost) {
        if (!self._portsConfigStore.configApiUrl) {
            return false;
        }
        return targetHost.host === self._portsConfigStore.configApiUrl.host;
    }
    onRequest(ctx, callback) {
        const targetHost = self.getTargetHost(ctx);
        if (targetHost) {
            self._httpsValidation.validateRequest(targetHost);
            let context = self._connectionContextManager.getConnectionContextFromClientSocket(ctx.clientToProxyRequest.socket);
            const useSso = self._configStore.useSso(targetHost);
            const useNtlm = useSso || self._configStore.exists(targetHost);
            if (context) {
                if (context.matchHostOrNew(targetHost, ctx.isSSL) === false) {
                    self._debug.log("Existing client socket " +
                        context.clientAddress +
                        " received request to a different target, remove existing context");
                    self._connectionContextManager.removeAgent("reuse", context.clientAddress);
                    context = undefined;
                }
            }
            if (!context) {
                context = self._connectionContextManager.createConnectionContext(ctx.clientToProxyRequest.socket, ctx.isSSL, targetHost);
            }
            if (self._upstreamProxyManager.hasHttpsUpstreamProxy(targetHost)) {
                self._upstreamProxyManager.setUpstreamProxyHeaders(ctx.proxyToServerRequestOptions.headers);
            }
            if (self.isConfigApiRequest(targetHost)) {
                self._debug.log("Request to config API");
                ctx.proxyToServerRequestOptions.agent =
                    self._connectionContextManager.getUntrackedAgent(targetHost);
                context.configApiConnection = true;
            }
            else if (useNtlm) {
                self._debug.log("Request to " +
                    targetHost.href +
                    " in registered NTLM Hosts" +
                    (useSso ? " (using SSO)" : ""));
                ctx.proxyToServerRequestOptions.agent = context.agent;
                context.clearRequestBody();
                ctx.onRequestData(function (ctx, chunk, callback) {
                    context.addToRequestBody(chunk);
                    return callback(undefined, chunk);
                });
            }
            else {
                self._debug.log("Request to " + targetHost.href + " - pass on");
                ctx.proxyToServerRequestOptions.agent = context.agent;
            }
            return callback();
        }
        else {
            // The http-mitm-proxy cannot handle this scenario, if no target host header
            // is set it will get stuck in an infinite loop
            return callback(new Error('Invalid request - Could not read "host" header or "host" header refers to this proxy'));
        }
    }
    isNtlmProxyAddress(hostUrl) {
        if (!self._portsConfigStore.ntlmProxyUrl) {
            return false;
        }
        return hostUrl.host === self._portsConfigStore.ntlmProxyUrl.host;
    }
    getTargetHost(ctx) {
        if (!ctx.clientToProxyRequest.headers.host) {
            self._debug.log('Invalid request - Could not read "host" header from incoming request to proxy');
            return null;
        }
        const host = ctx.clientToProxyRequest.headers.host;
        self._debug.log("getTargetHost - host header ", host);
        const hostUrl = new URL((ctx.isSSL ? "https://" : "http://") + host);
        if (self.isNtlmProxyAddress(hostUrl)) {
            self._debug.log("Invalid request - host header refers to this proxy");
            return null;
        }
        return hostUrl;
    }
    getAuthMode(serverToProxyResponse, useSso) {
        if (serverToProxyResponse.statusCode !== 401 ||
            !serverToProxyResponse.headers["www-authenticate"]) {
            return 0 /* AuthModeEnum.NotApplicable */;
        }
        if (useSso &&
            self._negotiateManager.acceptsNegotiateAuthentication(serverToProxyResponse)) {
            return 4 /* AuthModeEnum.Negotiate */;
        }
        if (self._ntlmManager.acceptsNtlmAuthentication(serverToProxyResponse)) {
            return 3 /* AuthModeEnum.NTLM */;
        }
        // TODO Basic auth
        return 1 /* AuthModeEnum.NotSupported */;
    }
    onResponse(ctx, callback) {
        const targetHost = self.getTargetHost(ctx);
        if (!targetHost) {
            return callback();
        }
        const useSso = self._configStore.useSso(targetHost);
        const useNtlm = useSso || self._configStore.exists(targetHost);
        if (!useNtlm) {
            return callback();
        }
        const context = self._connectionContextManager.getConnectionContextFromClientSocket(ctx.clientToProxyRequest.socket);
        if (context && context.canStartAuthHandshake(targetHost)) {
            const authMode = self.getAuthMode(ctx.serverToProxyResponse, useSso);
            if (authMode === 0 /* AuthModeEnum.NotApplicable */) {
                return callback();
            }
            if (authMode === 1 /* AuthModeEnum.NotSupported */) {
                self._debug.log("Received 401 with unsupported protocol in www-authenticate header.", ctx.serverToProxyResponse.headers["www-authenticate"], "Ignoring.");
                return callback();
            }
            // Grab PeerCertificate for NTLM channel binding
            if (ctx.isSSL) {
                const tlsSocket = ctx.serverToProxyResponse.connection;
                const peerCert = tlsSocket.getPeerCertificate();
                // getPeerCertificate may return an empty object.
                // Validate that it has fingerprint256 attribute (added in Node 9.8.0)
                if (peerCert.fingerprint256) {
                    context.peerCert = peerCert;
                }
                else {
                    self._debug.log("Could not retrieve PeerCertificate for NTLM channel binding.");
                }
            }
            if (authMode === 4 /* AuthModeEnum.Negotiate */) {
                self._debug.log("Received 401 with Negotiate in www-authenticate header. Starting handshake.");
                if (useSso) {
                    context.winSso = self._winSsoFacadeFactory.create("Negotiate", ctx.proxyToServerRequestOptions.host, context.peerCert, undefined);
                }
                self._negotiateManager.handshake(ctx, targetHost, context, (err, res) => self.handshakeCallback(ctx, err, res));
            }
            if (authMode === 3 /* AuthModeEnum.NTLM */) {
                self._debug.log("Received 401 with NTLM in www-authenticate header. Starting handshake.");
                if (useSso) {
                    context.winSso = self._winSsoFacadeFactory.create("NTLM", ctx.proxyToServerRequestOptions.host, context.peerCert, undefined);
                }
                self._ntlmManager.handshake(ctx, targetHost, context, useSso, (err, res) => self.handshakeCallback(ctx, err, res));
            }
        }
        else {
            return callback();
        }
    }
    handshakeCallback(ctx, err, res) {
        var _a, _b;
        if (err) {
            self._debug.log("Cannot perform handshake.", err);
        }
        if (res) {
            if (ctx.clientToProxyRequest.headers["proxy-connection"]) {
                res.headers["proxy-connection"] = "keep-alive";
                if (res.statusCode && res.statusCode !== 401) {
                    res.headers["connection"] = "keep-alive";
                }
                else {
                    res.headers["connection"] = "close";
                }
            }
            if (res.statusCode) {
                ctx.proxyToClientResponse.writeHead(res.statusCode, res.statusMessage, self.filterAndCanonizeHeaders(res.headers));
            }
            else {
                ctx.proxyToClientResponse.writeHead(401, self.filterAndCanonizeHeaders(res.headers));
            }
            res.on("data", (chunk) => ctx.proxyToClientResponse.write(chunk));
            res.on("end", () => ctx.proxyToClientResponse.end());
            res.resume();
        }
        else {
            // No response available, means that an network error occured on the connection to the target host
            // Signal this to generic error handling by destroying the original request socket
            (_a = ctx.proxyToServerRequest.socket) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = ctx.proxyToClientResponse.socket) === null || _b === void 0 ? void 0 : _b.destroy();
        }
    }
    onConnect(req, socket, head, callback) {
        if (!req.url) {
            self._debug.log("Invalid connect request - cannot read target url");
            return callback();
        }
        const targetHost = new URL(`https://${req.url}`); // On CONNECT the req.url includes target host
        if (self._configStore.existsOrUseSso(targetHost)) {
            return callback();
        }
        if (self._upstreamProxyManager.hasHttpsUpstreamProxy(targetHost)) {
            // Don't tunnel if we need to go through an upstream proxy
            return callback();
        }
        self._httpsValidation.validateConnect(targetHost);
        // Let non-NTLM hosts tunnel through
        self._debug.log("Tunnel to", req.url);
        const onPrematureClose = function () {
            self._debug.log("cannot establish connection to server, CONNECT failed");
            socket.end("HTTP/1.1 502 Bad Gateway\r\n\r\n", "utf8");
        };
        const connClosed = function (socket) {
            self._debug.log("server closed tunnel socket to ", req.url);
            self._connectionContextManager.removeTunnel(socket);
            if (!socket.readableFlowing && socket.writable) {
                // Pipe not established, signal close to server
                self._debug.log("closing client tunnel to ", req.url);
                socket.end();
            }
        };
        const socketClosed = function (conn) {
            self._debug.log("client closed tunnel socket to ", req.url);
            if (!conn.readableFlowing && conn.writable) {
                // Pipe not established, signal close to server
                self._debug.log("closing server tunnel to ", req.url);
                conn.end();
            }
        };
        const conn = net_1.default.connect({
            port: url_ext_1.URLExt.portOrDefault(targetHost),
            host: url_ext_1.URLExt.unescapeHostname(targetHost),
        }, function () {
            conn.removeListener("close", onPrematureClose);
            conn.once("finish", () => connClosed(socket));
            conn.once("close", () => connClosed(socket));
            socket.once("close", () => socketClosed(conn));
            socket.once("finish", () => socketClosed(conn));
            socket.write("HTTP/1.1 200 OK\r\n\r\n", "utf8", function () {
                conn.write(head);
                conn.pipe(socket);
                socket.pipe(conn);
                self._connectionContextManager.addTunnel(socket, conn);
            });
        });
        conn.once("close", onPrematureClose);
        conn.on("error", function (err) {
            filterSocketConnReset(err, "PROXY_TO_SERVER_SOCKET", req.url);
        });
        socket.on("error", function (err) {
            filterSocketConnReset(err, "CLIENT_TO_PROXY_SOCKET", req.url);
        });
        conn.setNoDelay();
        socket.setNoDelay();
        // Since node 0.9.9, ECONNRESET on sockets are no longer hidden
        // eslint-disable-next-line jsdoc/require-jsdoc
        function filterSocketConnReset(err, socketDescription, url) {
            if (err.code === "ECONNRESET") {
                self._debug.log("Got ECONNRESET on " +
                    socketDescription +
                    ", ignoring. Target: " +
                    url);
            }
            else {
                self._debug.log("Got unexpected error on " + socketDescription + ". Target: " + url, err);
            }
        }
    }
    filterAndCanonizeHeaders(originalHeaders) {
        const headers = {};
        for (const key in originalHeaders) {
            if (originalHeaders.hasOwnProperty(key)) {
                const canonizedKey = key.trim();
                if (/^public\-key\-pins/i.test(canonizedKey)) {
                    // HPKP header => filter
                    continue;
                }
                if (httpTokenRegExp.test(canonizedKey)) {
                    headers[canonizedKey] = originalHeaders[key];
                }
            }
        }
        return headers;
    }
    onWebSocketClose(ctx, code, message, callback) {
        // The default behavior of http-mitm-proxy causes exceptions on network errors on websockets
        // so we need to override it
        if (code === 1005 || code === 1006) {
            if (ctx.closedByServer) {
                self._debug.log("ProxyToServer websocket closed due to connectivity issue, terminating ClientToProxy websocket. Target:", ctx.proxyToServerWebSocket.url);
                return ctx.clientToProxyWebSocket.terminate();
            }
            else {
                self._debug.log("ClientToProxy websocket closed due to connectivity issue, terminating ProxyToServer websocket. Target:", ctx.proxyToServerWebSocket.url);
                return ctx.proxyToServerWebSocket.terminate();
            }
        }
        return callback();
    }
};
NtlmProxyMitm = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.inject)(dependency_injection_types_1.TYPES.IConfigStore)),
    __param(1, (0, inversify_1.inject)(dependency_injection_types_1.TYPES.IPortsConfigStore)),
    __param(2, (0, inversify_1.inject)(dependency_injection_types_1.TYPES.IConnectionContextManager)),
    __param(3, (0, inversify_1.inject)(dependency_injection_types_1.TYPES.IWinSsoFacadeFactory)),
    __param(4, (0, inversify_1.inject)(dependency_injection_types_1.TYPES.INegotiateManager)),
    __param(5, (0, inversify_1.inject)(dependency_injection_types_1.TYPES.INtlmManager)),
    __param(6, (0, inversify_1.inject)(dependency_injection_types_1.TYPES.IUpstreamProxyManager)),
    __param(7, (0, inversify_1.inject)(dependency_injection_types_1.TYPES.IHttpsValidation)),
    __param(8, (0, inversify_1.inject)(dependency_injection_types_1.TYPES.IDebugLogger)),
    __metadata("design:paramtypes", [Object, Object, Object, Object, Object, Object, Object, Object, Object])
], NtlmProxyMitm);
exports.NtlmProxyMitm = NtlmProxyMitm;
